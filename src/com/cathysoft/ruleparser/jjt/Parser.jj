/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*//**
 * JJTree template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";
  STATIC = false;
               
  DEBUG_PARSER = true;
                 }PARSER_BEGIN(Parser)package com.cathysoft.ruleparser.jjt;

import java.io.*;

public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

/*@egen*/  public static void main(String args [])  {    InputStream is = ClassLoader.getSystemResourceAsStream("example1.txt");    Parser parser = new Parser(is);    try    {		ASTExpression root = parser.parse();
		root.dump(" >");
		    }    catch (Exception e)    {      System.out.println("Oops.");      System.out.println(e.getMessage());    }  }}PARSER_END(Parser)
ASTExpression parse()             : {/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
  try {
/*@egen*/
  < RULE >
  "("
  ContextClasses()
  ")"
  < LBRACKETS >
  ( LOOKAHEAD(2)
    "<" < NOT_EMPTY > ">"
    NotEmptyExp()  )?
  ( LOOKAHEAD(2)
    "<" < CHECK > ">"
    (
      CheckExp()    )+  )?
  < RBRACKETS >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {
    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void ContextClasses() :{/*@bgen(jjtree) ContextClasses */
  ASTContextClasses jjtn000 = new ASTContextClasses(JJTCONTEXTCLASSES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ContextClasses */
  try {
/*@egen*/
  SignatureExp()
  (
	","
    SignatureExp()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void NotEmptyExp() :
{/*@bgen(jjtree) NotEmptyExp */
  ASTNotEmptyExp jjtn000 = new ASTNotEmptyExp(JJTNOTEMPTYEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NotEmptyExp */
  try {
/*@egen*/
  < ALL > < BUT >
  
  PathExp()
  (
    ","
    PathExp()
  )*
| PathExp()
  (
    ","
     PathExp()
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void CheckExp()      :
{}
{
   AssertionExp()
|  DerivationExp()}

void AssertionExp() :{/*@bgen(jjtree) AssertionExp */
  ASTAssertionExp jjtn000 = new ASTAssertionExp(JJTASSERTIONEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) AssertionExp */
  try {
/*@egen*/
  < ASSERT >
  "("
  	PathExp()
  	","
  	< STRING_LITERAL >
  ")"
  LogicalExp()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void DerivationExp() :{/*@bgen(jjtree) DerivationExp */
  ASTDerivationExp jjtn000 = new ASTDerivationExp(JJTDERIVATIONEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) DerivationExp */
  try {
/*@egen*/
  < DERIVATION >
  "("
  	PathExp()
  	","
  	< STRING_LITERAL >
  ")"
  DerivationBody()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void LogicalExp() :{/*@bgen(jjtree) LogicalExp */
  ASTLogicalExp jjtn000 = new ASTLogicalExp(JJTLOGICALEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LogicalExp */
 try {
/*@egen*/LOOKAHEAD(2)
  LogicalBody()
| FunctionExp()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/}

void LogicalBody() :{/*@bgen(jjtree) LogicalBody */
  ASTLogicalBody jjtn000 = new ASTLogicalBody(JJTLOGICALBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) LogicalBody */
  try {
/*@egen*/
  (
    OperatorExp()
    < LOGIC_OPER >
    OperatorExp()
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void DerivationBody() :{/*@bgen(jjtree) DerivationBody */
  ASTDerivationBody jjtn000 = new ASTDerivationBody(JJTDERIVATIONBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DerivationBody */
  try {
/*@egen*/
  LogicalExp()
  < DERIVATION_OPER >
  LogicalExp()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void OperatorExp() :
{/*@bgen(jjtree) OperatorExp */
  ASTOperatorExp jjtn000 = new ASTOperatorExp(JJTOPERATOREXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) OperatorExp */
  try {
/*@egen*/ LOOKAHEAD(2)
  PathExp()
| FunctionExp()
| < INTEGER_LITERAL >
| < STRING_LITERAL >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void FunctionExp()           :{/*@bgen(jjtree) Function */
  ASTFunction jjtn000 = new ASTFunction(JJTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Function */
  try {
/*@egen*/ 
  < IDENTIFIER >
  "("
  Arguments()
  ")"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void Arguments() :{/*@bgen(jjtree) Arguments */
  ASTArguments jjtn000 = new ASTArguments(JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Arguments */
  try {
/*@egen*/
  (
    < INTEGER_LITERAL >
  | < STRING_LITERAL >
  | PathExp()
  )
  (
    ","
    (      < INTEGER_LITERAL >
    | < STRING_LITERAL >
    | PathExp()
    )
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void PathExp()       :
{/*@bgen(jjtree) Path */
  ASTPath jjtn000 = new ASTPath(JJTPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) Path */
  try {
/*@egen*/
  < IDENTIFIER >  < DOT >
  < IDENTIFIER >/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SignatureExp()            :{/*@bgen(jjtree) Signature */
  ASTSignature jjtn000 = new ASTSignature(JJTSIGNATURE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) Signature */
  try {
/*@egen*/
  < IDENTIFIER >
  (
    < DOT >
    < IDENTIFIER >
  )*/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
SKIP :{  " "| "\t"| "\n"| "\r"| < "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >| < "/*" (~[ "*" ])* "*"    (      ~[ "/" ] (~[ "*" ])* "*"    )*    "/" >}

TOKEN [IGNORE_CASE] : /* KEYWORDS */
{
  < RULE : "RULE" >
| < NOT_EMPTY : "NOT EMPTY" >
| < ALL : "ALL" >
| < BUT : "BUT" >
| < CHECK : "CHECK" >
| < ASSERT : "ASSERT" >
| < DERIVATION : "DERIVATION" >}
TOKEN : /* OPERATOR */
{
  < LOGIC_OPER : "=" | ">" | "<" | ">=" | "<=" | "<>" >
| < DERIVATION_OPER : "->" >
| < DOT : "." >
| < LBRACKETS : "{" >
| < RBRACKETS : "}" >
| < QUOTE : "\"" >
}
TOKEN : /* LITERALS */{  < INTEGER_LITERAL :    < DECIMAL_LITERAL > ([ "l", "L" ])?  | < HEX_LITERAL > ([ "l", "L" ])?  | < OCTAL_LITERAL > ([ "l", "L" ])?     >| < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* >| < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >}TOKEN : /* IDENTIFIERS */{  < IDENTIFIER :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < #LETTER : [ "_", "a"-"z", "A"-"Z" ] >| < #DIGIT : [ "0"-"9" ] >}
TOKEN : /* STRING LETERALS */
{
  < STRING_LITERAL:
      < QUOTE >
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      < QUOTE >
  >}

